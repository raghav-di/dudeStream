<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Video Streaming Room</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Inter', sans-serif;
    }
    #file-input {
      font-size: 12px;
      padding: 2px;
      margin-left: 4px;
      flex-direction: column;
      height: 60px;
      width: 100px;
      text-align: center;
    }
  </style>
</head>

<body class="bg-gray-900 text-slate-200 flex flex-col min-h-screen">

  <!-- Header -->
  <header class="bg-gray-800 shadow-lg z-10">
    <div class="container mx-auto px-4 sm:px-6 lg:px-8">
      <div class="flex items-center justify-between h-16">
        <div class="flex items-center">
          <span class="font-semibold text-lg text-white">Room Code:</span>
          <strong id="roomCode" class="ml-2 text-lg bg-gray-700 text-green-400 px-3 py-1 rounded-md tracking-wider"></strong>
        </div>
        <div class="flex items-center space-x-2 sm:space-x-4">
          <label for="fileInput" id="file-input" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg cursor-pointer flex items-center transition duration-300 ease-in-out transform hover:scale-105">
            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
            <span>Stream Video File</span>
          </label>
          <input type="file" id="fileInput" class="hidden" accept="video/*">
        </div>
      </div>
    </div>
  </header>

  <!-- Main Content -->
  <main class="flex-grow container mx-auto px-4 sm:px-6 lg:px-8 py-8 flex items-center justify-center">
    <div class="w-full max-w-6xl aspect-video bg-black rounded-2xl shadow-2xl overflow-hidden relative">
      <video id="videoPlayer" class="w-full h-full object-contain" autoplay controls playsinline></video>
      <div id="placeholder" class="absolute inset-0 flex items-center justify-center text-gray-500 text-2xl">
        <p>Select a video file to start streaming...</p>
      </div>
    </div>
  </main>

  <!-- Container for remote audio streams -->
  <div id="audioContainer"></div>

  <script>
    (async function() {
      const roomCodeDisplay = document.getElementById('roomCode');
      const fileInput = document.getElementById('fileInput');
      const videoPlayer = document.getElementById('videoPlayer');
      const placeholder = document.getElementById('placeholder');
      const audioContainer = document.getElementById('audioContainer');

      let localVideoStream = null;
      let localAudioStream = null;
      const peerConnections = {};
      const roomName = generateRoomName();
      roomCodeDisplay.textContent = roomName;

      // --- Get user's mic (optional) ---
      try {
        localAudioStream = await navigator.mediaDevices.getUserMedia({
          video: false,
          audio: true
        });
      } catch (err) {
        console.warn("Microphone access denied or not available.", err);
      }

      // --- WebSocket signaling setup ---
      const wsProtocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
      const ws = new WebSocket(`${wsProtocol}${window.location.host}/ws/signaling/${roomName}/`);

      const configuration = {
        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
      };

      function generateRoomName() {
        return [...Array(16)].map(() =>
          (Math.random() * 62 | 0).toString(36)
        ).map(c => Math.random() < 0.5 ? c : c.toUpperCase()).join('');
      }

      function hidePlaceholder() {
        placeholder.style.display = 'none';
      }

      // --- Create PeerConnection ---
      function createPeerConnection(peerId, isInitiator) {
        const pc = new RTCPeerConnection(configuration);
        peerConnections[peerId] = pc;

        if (localAudioStream) {
          localAudioStream.getTracks().forEach(track => pc.addTrack(track, localAudioStream));
        }
        if (localVideoStream) {
          localVideoStream.getTracks().forEach(track => pc.addTrack(track, localVideoStream));
        }

        if (isInitiator) {
          pc.createOffer()
            .then(offer => pc.setLocalDescription(offer))
            .then(() => ws.send(JSON.stringify({
              type: 'offer',
              target: peerId,
              offer: pc.localDescription
            })));
        }

        pc.onicecandidate = (event) => {
          if (event.candidate) {
            ws.send(JSON.stringify({ type: 'candidate', target: peerId, candidate: event.candidate }));
          }
        };

        pc.ontrack = (event) => {
          if (event.track.kind === 'audio') {
            let audioEl = document.getElementById(`audio-${peerId}`);
            if (!audioEl) {
              audioEl = document.createElement('audio');
              audioEl.id = `audio-${peerId}`;
              audioEl.autoplay = true;
              audioContainer.appendChild(audioEl);
            }
            audioEl.srcObject = event.streams[0];
          }
        };

        return pc;
      }

      // --- WebSocket Events ---
      ws.onopen = () => console.log('WebSocket connected.');
      ws.onmessage = async (event) => {
        const data = JSON.parse(event.data);
        const peerId = data.sender;
        if (!peerId) return;

        let pc = peerConnections[peerId];
        switch (data.type) {
          case 'join':
            createPeerConnection(peerId, true);
            break;
          case 'answer':
            if (pc) await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
            break;
          case 'candidate':
            if (pc && data.candidate && pc.remoteDescription) {
              await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
            }
            break;
        }
      };

      // --- File Input: Start Streaming Video ---
      fileInput.addEventListener('change', async (event) => {
        const file = event.target.files[0];
        if (!file) return;

        const url = URL.createObjectURL(file);
        videoPlayer.src = url;
        hidePlaceholder();

        try {
          await videoPlayer.play();
          const stream = videoPlayer.captureStream ? videoPlayer.captureStream() : videoPlayer.mozCaptureStream();
          localVideoStream = stream;

          // Add or replace video tracks for all peers
          for (const peerId in peerConnections) {
            const pc = peerConnections[peerId];
            stream.getTracks().forEach(track => {
              const sender = pc.getSenders().find(s => s.track && s.track.kind === track.kind);
              if (sender) {
                sender.replaceTrack(track);
              } else {
                pc.addTrack(track, stream);
              }
            });
          }
        } catch (err) {
          console.error("Error playing or streaming video:", err);
        }
      });

      // --- Optional: Sync play/pause actions ---
      videoPlayer.onplay = () => {
        ws.send(JSON.stringify({ type: 'play' }));
      };
      videoPlayer.onpause = () => {
        ws.send(JSON.stringify({ type: 'pause' }));
      };
    })();
  </script>
</body>
</html>